/**
 * Crucible
 * Copyright 2020 Carnegie Mellon University.
 * NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
 * Released under a MIT (SEI)-style license, please see license.txt or contact permission@sei.cmu.edu for full terms.
 * [DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.  Please see Copyright notice for non-US Government use and distribution.
 * Carnegie Mellon(R) and CERT(R) are registered in the U.S. Patent and Trademark Office by Carnegie Mellon University.
 * DM20-0181
 */

/**
 * Player VM API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { BulkPowerOperation } from '../model/bulkPowerOperation';
import { BulkPowerOperationResponse } from '../model/bulkPowerOperationResponse';
import { ProblemDetails } from '../model/problemDetails';
import { Vm } from '../model/vm';
import { VmCreateForm } from '../model/vmCreateForm';
import { VmUpdateForm } from '../model/vmUpdateForm';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class VmsService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Adds a Virtual Machine to a Team
     * Creates a new Virtual Machine with the attributes specified  &lt;para /&gt;  Accessible to a User with management permissions on a team the Virtual Machine will be added to
     * @param vmId The id of the Virtual Machine
     * @param teamId The id of the Team
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addVmToTeam(vmId: string, teamId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addVmToTeam(vmId: string, teamId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addVmToTeam(vmId: string, teamId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addVmToTeam(vmId: string, teamId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (vmId === null || vmId === undefined) {
            throw new Error('Required parameter vmId was null or undefined when calling addVmToTeam.');
        }
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling addVmToTeam.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.post<any>(`${this.configuration.basePath}/api/teams/${encodeURIComponent(String(teamId))}/vms/${encodeURIComponent(String(vmId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Power off multiple Virtual Machines
     * @param BulkPowerOperation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bulkPowerOff(BulkPowerOperation?: BulkPowerOperation, observe?: 'body', reportProgress?: boolean): Observable<BulkPowerOperationResponse>;
    public bulkPowerOff(BulkPowerOperation?: BulkPowerOperation, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BulkPowerOperationResponse>>;
    public bulkPowerOff(BulkPowerOperation?: BulkPowerOperation, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BulkPowerOperationResponse>>;
    public bulkPowerOff(BulkPowerOperation?: BulkPowerOperation, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<BulkPowerOperationResponse>(`${this.configuration.basePath}/api/vms/actions/power-off`,
            BulkPowerOperation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Power on multiple Virtual Machines
     * @param BulkPowerOperation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bulkPowerOn(BulkPowerOperation?: BulkPowerOperation, observe?: 'body', reportProgress?: boolean): Observable<BulkPowerOperationResponse>;
    public bulkPowerOn(BulkPowerOperation?: BulkPowerOperation, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BulkPowerOperationResponse>>;
    public bulkPowerOn(BulkPowerOperation?: BulkPowerOperation, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BulkPowerOperationResponse>>;
    public bulkPowerOn(BulkPowerOperation?: BulkPowerOperation, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<BulkPowerOperationResponse>(`${this.configuration.basePath}/api/vms/actions/power-on`,
            BulkPowerOperation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Shutdown multiple Virtual Machines
     * @param BulkPowerOperation 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public bulkShutdown(BulkPowerOperation?: BulkPowerOperation, observe?: 'body', reportProgress?: boolean): Observable<BulkPowerOperationResponse>;
    public bulkShutdown(BulkPowerOperation?: BulkPowerOperation, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BulkPowerOperationResponse>>;
    public bulkShutdown(BulkPowerOperation?: BulkPowerOperation, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BulkPowerOperationResponse>>;
    public bulkShutdown(BulkPowerOperation?: BulkPowerOperation, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<BulkPowerOperationResponse>(`${this.configuration.basePath}/api/vms/actions/shutdown`,
            BulkPowerOperation,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Virtual Machine
     * Creates a new Virtual Machine with the attributes specified  &lt;para /&gt;  Accessible to a User with management permissions on a team the Virtual Machine will be added to
     * @param VmCreateForm The data to create the Team with
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createVm(VmCreateForm?: VmCreateForm, observe?: 'body', reportProgress?: boolean): Observable<Vm>;
    public createVm(VmCreateForm?: VmCreateForm, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Vm>>;
    public createVm(VmCreateForm?: VmCreateForm, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Vm>>;
    public createVm(VmCreateForm?: VmCreateForm, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Vm>(`${this.configuration.basePath}/api/vms`,
            VmCreateForm,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes a Vm
     * Deletes a Vm with the specified id  &lt;para /&gt;  Accessible to a User with management permission on a team the Virtual Machine is in
     * @param id The id of the Vm
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteVm(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteVm(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteVm(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteVm(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteVm.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/api/vms/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve all Vms
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAll(observe?: 'body', reportProgress?: boolean): Observable<Array<Vm>>;
    public getAll(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Vm>>>;
    public getAll(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Vm>>>;
    public getAll(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Vm>>(`${this.configuration.basePath}/api/vms`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all of the Vms in the specified Team
     * @param teamId 
     * @param name An optional search term for the vm\&#39;s name
     * @param includePersonal 
     * @param onlyMine 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTeamVms(teamId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Vm>>;
    public getTeamVms(teamId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Vm>>>;
    public getTeamVms(teamId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Vm>>>;
    public getTeamVms(teamId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling getTeamVms.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (includePersonal !== undefined && includePersonal !== null) {
            queryParameters = queryParameters.set('includePersonal', <any>includePersonal);
        }
        if (onlyMine !== undefined && onlyMine !== null) {
            queryParameters = queryParameters.set('onlyMine', <any>onlyMine);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Vm>>(`${this.configuration.basePath}/api/teams/${encodeURIComponent(String(teamId))}/vms`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all of the Vms the calling user has access to in the specified View
     * @param viewId The Id of the View
     * @param name An optional search term for the vm\&#39;s name
     * @param includePersonal 
     * @param onlyMine 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getViewVms(viewId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<Vm>>;
    public getViewVms(viewId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Vm>>>;
    public getViewVms(viewId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Vm>>>;
    public getViewVms(viewId: string, name?: string, includePersonal?: boolean, onlyMine?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (viewId === null || viewId === undefined) {
            throw new Error('Required parameter viewId was null or undefined when calling getViewVms.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (name !== undefined && name !== null) {
            queryParameters = queryParameters.set('name', <any>name);
        }
        if (includePersonal !== undefined && includePersonal !== null) {
            queryParameters = queryParameters.set('includePersonal', <any>includePersonal);
        }
        if (onlyMine !== undefined && onlyMine !== null) {
            queryParameters = queryParameters.set('onlyMine', <any>onlyMine);
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Array<Vm>>(`${this.configuration.basePath}/api/views/${encodeURIComponent(String(viewId))}/vms`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve a single Vm by Id
     * @param id The Id of the Vm
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getVm(id: string, observe?: 'body', reportProgress?: boolean): Observable<Vm>;
    public getVm(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Vm>>;
    public getVm(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Vm>>;
    public getVm(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getVm.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<Vm>(`${this.configuration.basePath}/api/vms/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes a Virtual Machine from a Team
     * Removes the specified Virtual Machine from the specified Team  &lt;para /&gt;  Accessible to a User with management permissions on a team the Virtual Machine will be added to
     * @param vmId The id of the Virtual Machine
     * @param teamId The id of the Team
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeVmFromTeam(vmId: string, teamId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeVmFromTeam(vmId: string, teamId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeVmFromTeam(vmId: string, teamId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeVmFromTeam(vmId: string, teamId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (vmId === null || vmId === undefined) {
            throw new Error('Required parameter vmId was null or undefined when calling removeVmFromTeam.');
        }
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling removeVmFromTeam.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.delete<any>(`${this.configuration.basePath}/api/teams/${encodeURIComponent(String(teamId))}/vms/${encodeURIComponent(String(vmId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates a new Virtual Machine
     * Updates a Virtual Machine with the attributes specified  &lt;para /&gt;  Accessible to a User with management permissions on a team the Virtual Machine is in
     * @param id 
     * @param VmUpdateForm The data to update the Virtual Machine with
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateVm(id: string, VmUpdateForm?: VmUpdateForm, observe?: 'body', reportProgress?: boolean): Observable<Vm>;
    public updateVm(id: string, VmUpdateForm?: VmUpdateForm, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Vm>>;
    public updateVm(id: string, VmUpdateForm?: VmUpdateForm, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Vm>>;
    public updateVm(id: string, VmUpdateForm?: VmUpdateForm, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVm.');
        }

        let headers = this.defaultHeaders;

        // authentication (oauth2) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json',
            'text/json',
            'application/_*+json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Vm>(`${this.configuration.basePath}/api/vms/${encodeURIComponent(String(id))}`,
            VmUpdateForm,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
